#summary Description of the NDT Protocol

= Network Diagnostic Tool Protocol (NDTP) =

== Abstract == 

Network Diagnostic Tool (NDT) is a client/server program that provides network configuration and performance testing to a user's computer. It uses a well-defined protocol to provide a reliable communication link between its subcomponents. This protocol documentation is sufficient to allow outside parties to write compatible NDT clients without consulting the NDT source code. This documentation contains a state transition diagrams detailing the various states that the components (both server and client) can be in, and the valid messages that can or will be transmitted or received in those states.

== Table of Contents ==

<wiki:toc max_depth="4" />

== Introduction ==

Several studies have shown that the majority of network performance problems occur in or near the users’ desktop/laptop computer.  These problems include, but are not limited to, duplex mismatch conditions on Ethernet/FastEthernet links, incorrectly set TCP buffers in the user’s computer, or problems with the local network infrastructure. NDT seeks to determine why a network connection exhibits certain performance characteristics. In addition to measuring the familiar upload and download speeds of a user's connection, NDT also performs tests that can assess factors such as latency, packet loss, congestion, bad cables, and bottlenecks on the end-to-end path from client to server. 

NDT popularity has grown in recent years, which led to an increased interest from the developers community around the world. People started to integrate NDT with their systems using different approaches, like adding Web Developer's API to Web based (java applet) client and writing new mobile (Android based) client.

NDTP is allowing outside parties to easily extend both NDT server and client parts and write compatible clients in new languages that will be able to communicate with the publicly available Measurement Lab servers.

In this document, the key words "MUST", "REQUIRED", "SHOULD", "RECOMMENDED", and "MAY" are to be interpreted as described in [http://www.ietf.org/rfc/rfc2119.txt RFC2119].

=== Relationship of Tests and Control Protocols ===

NDTP actually consists of two inter-related sets of protocols: NDTP-Control and NDTP-Tests. NDTP-Control is used to initiate, start, and stop test sessions and to fetch their results, whereas NDTP-Tests is a set of smaller sub-protocols used to exchange test packets between two measurement nodes.

NDTP-Tests consists of five smaller sub-protocols: Middlebox test, Simple firewall test, C2S throughput test, S2C throughput test and META test. These tests are completely independent from each other and can be run in any order. Moreover, new NDTP-Tests protocols can be easily created and integrated into the existing tests ecosystem.

NDTP-Control is designed to support the negotiation of test sessions and results retrieval in a straightforward manner. At session initiation, there is a negotiation of the test suite and session start time. Moreover, server version is being verified to discover the possibility of incompatibilities. Additionally, NDTP-Control defines an exact message format, which greatly increase the general protocol reliability and allows other NDTP-Tests protocols to communicate in a convenient and secure fashion.

We believe that NDTP-Control protocol can effectively be used to implement not only new types of clients, but also can be treated as a generic framework to create and combine with each other completely new NDTP-Tests protocols.

=== Logical Model ===

We can distinguish several different roles on both NDTP-Control and NDTP-Tests levels. Specifically, we define the following:

|| *Role* || *Description* ||
|| Session-Sender || The sending endpoint of a NDTP-Tests session. ||
|| Session-Receiver || The receiving endpoint of a NDTP-Tests session. ||
|| Server || An end system that manages NDTP-Control and NDTP-Tests sessions, performs the specific tests needed to determine what problems, if any, exist. The server process then analyzes the test results and returns these results to the client. ||
|| Client || An end system that initiates requests for NDTP-Tests sessions, triggers the start of a set of sessions and receives tests results. ||

Different logical roles can be played by the same host. For example Server machine is a Session-Sender in the S2C throughput test, while it is a Session-Receiver in the C2S throughput test.

For example, please look at the figures describing two main NDTP-Tests protocols:

 * C2S throughput test

{{{
       +----------------+                    +------------------+
       |     Client     |<---NDTP-Control--->|     Server       |
       |                |                    |                  |
       | Session-Sender |----NDTP-Test------>| Session-Receiver |
       +----------------+                    +------------------+
}}}

 * S2C throughput test

{{{
       +------------------+                    +------------------+
       |     Client       |<---NDTP-Control--->|     Server       |
       |                  |                    |                  |
       | Session-Receiver |<---NDTP-Test-------|  Session-Sender  |
       +------------------+                    +------------------+
}}}

== Protocol Overview ==

As described above, NDTP consists of two inter-related sets of protocols: NDTP-Control and NDTP-Tests. Both of them are layered over TCP. The former is used to initiate and control test sessions and to fetch their results. The latter set of protocols is used to perform specific tests.

The initiator of the test session establishes a TCP connection to a well-known port, 3001, on the target point and this connection remains open for the duration of the NDTP-Tests sessions.  A NDT server SHOULD listen to this well-known port.

NDTP-Control messages are transmitted before NDTP-Tests sessions are actually started, after they are completed and between particular tests from the performed test suite. Moreover, specific tests also use NDTP-Control messages to synchronise test sessions, exchange configuration data and additional information.

All multi-octet quantities defined in this document are represented as unsigned integers in network byte order unless specified otherwise.

== NDTP-Control ==

The type of each NDTP-Control message can be found after reading the first octet. The length of each NDTP-Control message can be computed upon reading its fixed-size part. No message is shorter than 3 octets.

An implementation SHOULD expunge unused state to prevent denial-of-service attacks, or unbounded memory usage, on the server.  For example, if the full control message is not received within some number of minutes after it is expected, the TCP connection associated with the NDTP-Control session SHOULD be dropped.  In absence of other considerations, 10 minutes seems like a reasonable upper bound.

=== Message structure ===

Each of the NDTP-Control messages always has the following format:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      TYPE     |            LENTGH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     |                                                               |
     .                                                               .
     .                                                               .
     .                                                               .
     |                                                               |
     |                                                               |
     |                                                               |
     |                 Message (up to 65545 octets)                  |
     |                                                               |
     |                                                               |
     |                                                               |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

=== Message types ===

NDTP-Control currently defines the following types of messages:

|| *C constant name* || *Bit value* || *Description* ||
|| COMM_FAILURE || 0 || Notification about communication link failure. *Not used explicitly* ||
|| SRV_QUEUE || 1 || Message used to Clients' queue management ||
|| MSG_LOGIN || 2 || Used during initialisation to negotiate NDT version and test suite ||
|| TEST_PREPARE || 3 || Used to send all information needed for a particular test (i.e. port numbers, test time, etc.) ||
|| TEST_START || 4 || Message used to start a specific test ||
|| TEST_MSG || 5 || Used during tests to communicate between Client and Server ||
|| TEST_FINALIZE || 6 || Message used to end a specific test ||
|| MSG_ERROR || 7 || Used to send error messages and notifications about invalid states of the test session ||
|| MSG_RESULTS || 8 || Contains final test sessions' results ||
|| MSG_LOGOUT || 9 || This is the last message send by Server after MSG_RESULTS messages. Server SHOULD close the NDTP-Control connection after sending this message. ||
|| MSG_WAITING || 10 || Message from the Client to notify Server that the Client is still alive ||

=== Sequence diagram ===

A test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |---------------CONNECT---------------->|
               |                                       |
               |----------MSG_LOGIN (TESTS)----------->|
               |                                       |
               |<---------KICK OFF MESSAGE-------------|
               |                                       |
               |<---------SRV_QUEUE ("0")--------------|
               |                                       |
               |<-------MSG_LOGIN ("vVERSION")---------|
               |                                       |
               |<------MSG_LOGIN ("tests' ids")--------|
               |                                       |
               |                                       |
               |<-------------NDTP-Tests-------------->|
               .                                       .
               .                                       .
               .                                       .
               |<-------------NDTP-Tests-------------->|
               |                                       |
               |                                       |
               |<------------MSG_RESULTS---------------|
               .                                       .
               .                                       .
               .                                       .
               |<------------MSG_RESULTS---------------|
               |                                       |
               |<------------MSG_LOGOUT----------------|
               |                                       |
               |<---------CLOSE CONNECTION------------x|
}}}

=== Connection Setup ===

==== Logging in to server with a test suite request ====

Before Client can start test sessions, it has to establish a connection to the Server.

First, a Client opens a TCP connection to the Server on a well-known port 3001 and sends a LOGIN message:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      2        |              1                |     TESTS     |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

Where TESTS is a bitwise OR of the tests' ids that should be run in a requested test-suite.

All new Clients SHOULD always request TEST_STATUS (16 (1L << 4)) test in order to notify Server that they support MSG_WAITING messages introduced in NDT v3.5.5.

==== Kick off message to disconnect old clients ====

In the same time Server sends the specially crafted 13 octets long data that kicks off the old Clients ("123456 654321"):

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |     '1'       |     '2'       |     '3'       |     '4'       |
     |     '5'       |     '6'       |     ' '       |     '6'       |
     |     '5'       |     '4'       |     '3'       |     '2'       |
     |     '1'       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     +-+-+-+-+-+-+-+-+
}}}

All non-compatible Clients SHOULD drop the connection after receiving the above message.

==== Queuing clients ====

In the next step NDT Server is calculating if it can handle Client request and Client SHOULD expect at least one 'SRV_QUEUE' message. This message MAY contain one of the following string values:

|| *SRV_QUEUE value* || *Description* ||
|| "0" || Test session will start now ||
|| "9977" || Server Fault: test session will be terminated for unknown reason. Client SHOULD drop the connection after receiving this message. *Not used currently by the Server* ||
|| "9988" || If this is a first message from Server, then it means that Server is busy. In other cases it means Server Fault. Client SHOULD drop the connection after receiving this message. ||
|| "9999" || Server Busy: Please wait 60 seconds for the current test to finish. Client SHOULD drop the connection after receiving this message. *Deprecated/Not used by the Server* ||
|| "9990" || This is a check from Server to verify if the Client is alive. Available from v3.5.5. The Client SHOULD respond to this message by sending 'MSG_WAITING' empty message. Server will only send these messages when Client requested TEST_STATUS test. ||
|| "N" || Where N is any other value. It means the estimated number of minutes that Client will wait for its test to begin. ||

When Server decides that Client can start its test session, it sends SRV_QUEUE message with value *"0"*:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      1        |              1                |     '0'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}


==== Verifying version compatibility ====

At the beginning of the test session Server and Client MUST verify their version compatibility.

Server MUST send a MSG_LOGIN message containing its version identifier in the following form:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      2        |          LENGTH               |     'v'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                       VERSION number                          |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

where VERSION is the current NDT version, for example *3.6.4*.

It is RECOMMENDED, that Client will display a warning message in case of the difference. Moreover, Client MAY also drop a connection when incompatibility is too big.

==== Negotiating test suite ====

In the next step Server MUST send a MSG_LOGIN message containing a list of tests' ids that will be performed. This list is a string containing space separated numbers that describes particular tests. The test suite containing all five tests (Middlebox test, Simple firewall test, C2S throughput test, S2C throughput test and META test) will have the following description:
{{{
1 8 2 4 32
}}}

The tests MUST be performed in the order received from Server. It is RECOMMENDED that Client will drop the connection when it receives unknown test id.

=== Results retrieval ===

After the last accomplished NDTP-Tests test Server MUST send all gathered results to the client. These results MUST be sent in a set of MSG_RESULTS messages. All standard results are currently encoded as strings and MAY be displayed by Client directly on the screen without any modifications.

At the end Server MUST close the whole test session by sending an empty MSG_LOGOUT message and closing connection with the Client.

== NDTP-Tests ==

NDTP-Tests currently defines the following types of tests:

|| *C constant name* || *Integer value* || *Description* ||
|| TEST_MID || 1 (1L << 0) || Middlebox test - a short throughput S2C test with a limited CWND to check for a duplex mismatch condition. Moreover, it also checks the MSS value and does NAT detection ||
|| TEST_C2S || 2 (1L << 1) || C2S throughput test ||
|| TEST_S2C || 4 (1L << 2) || S2C throughput test ||
|| TEST_SFW || 8 (1L << 3) || Simple firewall test ||
|| TEST_META || 32 (1L << 5) || META test ||

Moreover, NDT v3.5.5 introduced a new mechanism to avoid zombie Clients (i.e. queued Clients that will never start their test session). In order to enable this mechanism Client MUST add the following test to its test suite request:

|| *C constant name* || *Integer value* || *Description* ||
|| TEST_STATUS || 16 (1L << 4) || Special flag to notify Server that this Client will respond to status requests ||

It is highly RECOMMENDED that all new Clients support TEST_STATUS mechanism.

=== Middlebox test ===

Middlebox test is a short throughput S2C test with a limited CWND to check for a duplex mismatch condition. Moreover, this test uses pre-defined MSS value to check if any intermediate node will modify its connection settings.

==== MID protocol ====

As a first step Server MUST bind new port and send TEST_PREPARE message containing this port number to Client. Port number must be encoded as string.

Next, Client MUST connect to this newly bound port and start reading data from Server.

Server SHOULD check MSS value and MUST start 5 seconds throughput test. When the test is over, Server MUST send its results encoded as strings in the TEST_MSG message to Client. These results have the following format:
{{{
ServerIP;ClientIP;CurMSS;WinScaleSent;WinScaleRecv
}}}

Next, Client MUST send to Server its calculated throughput value encoded as string (float format) in the TEST_MSG message.

At the end Server MUST close MID test session by sending an empty TEST_FINALIZE message.

=== Simple firewall test ===

Simple firewall test tries to find out any firewalls between Client and Server that will prevent connections to ephemeral port numbers. Test is performed in both directions (i.e. Client is trying to connect to Server (c2s) and Server is trying to connect to Client (s2c)).

==== Possible test results ====

Simple firewall test defines the following result codes for both c2s and s2c tests:

|| *C constant name* || *Integer value* || *Description* ||
|| SFW_NOTTESTED || 0 || Test was not started ||
|| SFW_NOFIREWALL || 1 || Test was successful (i.e. connection to ephemeral port was possible) ||
|| SFW_UNKNOWN || 2 || There was a connection to ephemeral port, but it was not recognized properly ||
|| SFW_POSSIBLE || 3 || There was no connection to ephemeral port within the specified time ||

==== SFW protocol ====

As a first step Server MUST bind ephemeral port and send TEST_PREPARE message containing this port number and test time (in seconds) to Client. Port number and test time MUST be encoded as strings and separated by a single space, for example:
{{{
50123 3
}}}

Next, Client MUST bind ephemeral port and send TEST_MSG message containing only this port number to Server. Port number MUST be encoded as string.

Server SHOULD start test by sending empty TEST_START message immediately after it receives Client's ephemeral port number.

Test SHOULD be performed in both direction in parallel. Client SHOULD try to connect to Server's ephemeral port and MUST send TEST_MSG message containing a pre-defined string "Simple firewall test" of length 20. The whole message looks as following:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            20                 |     'S'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |     'i'       |     'm'       |     'p'       |     'l'       |
     |     'e'       |     ' '       |     'f'       |     'i'       |
     |     'r'       |     'e'       |     'w'       |     'a'       |
     |     'l'       |     'l'       |     ' '       |     't'       |
     |     'e'       |     's'       |     't'       +-+-+-+-+-+-+-+-+
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

After performing Simple firewall test in both directions, Server MUST send to Client its c2s results encoded as string in the TEST_MSG message.

At the end Server MUST close SFW test session by sending an empty TEST_FINALIZE message.

=== C2S throughput test ===

C2S throughput test is the main NDT test based on streaming test data from Client to Server for 10 seconds.

==== C2S protocol ====

As a first step Server MUST bind new port and send TEST_PREPARE message containing this port number to Client. Port number must be encoded as string.

Next, Client MUST connect to this newly bound port.

In order to start the test, Server MUST send an empty TEST_START message.

Client MUST start 10 seconds throughput test and Server MUST read transmitted data.

When Client stops streaming test data (or the test routine at Server times out), Server MUST send to Client its calculated throughput value encoded as string (float format) in the TEST_MSG message.

At the end Server MUST close C2S test session by sending an empty TEST_FINALIZE message.

=== S2C throughput test ===

S2C throughput test is the main NDT test based on streaming test data from Server to Client for 10 seconds.

==== S2C protocol ====

As a first step Server MUST bind new port and send TEST_PREPARE message containing this port number to Client. Port number must be encoded as string.

Next, Client MUST connect to this newly bound port.

In order to start the test, Server MUST send an empty TEST_START message.

Server MUST start 10 seconds throughput test and Client MUST read transmitted data.

When Server stops streaming test data, it MUST send to Client its calculated throughput value (encoded as string in float format), amount of unsent data in the socket send queue (encoded as string in integer format) and overall number of sent bytes (encoded as string in float format) in the TEST_MSG message. All these values MUST be separated by spaces, i.e:
{{{
THROUGHPUT_VALUE SND_QUEUE SENT_BYTES
}}}

Next, Client MUST send to Server its calculated throughput value encoded as string (float format) in the TEST_MSG message.

In the same time Server SHOULD send its web100 data variables gathered during S2C throughput test to Client. Each variable name/value pair should be encoded as strings in a separate TEST_MSG message using the following format:
{{{
web100_var_NAME: web100_var_VALUE\n
}}}

where '\n' is a single new line character.

At the end Server MUST close S2C test session by sending an empty TEST_FINALIZE message.

=== META test ===

META test allows a Client to send additional information to Server to be stored along with the test results. Information received from Client is stored as key/value pairs.

==== key/value limits ====

Both parts (keys and values) of the meta data MUST be strings with the following constraints:
 * Keys MUST be shorter than 64 characters
 * Values MUST be shorter than 256 characters

==== META data keys ====

Although this protocol is generic enough to store any type of information (encoded as strings), it is RECOMMENDED to store at least the following data:

|| *C constant name* || *key value* || *Description* ||
|| META_CLIENT_OS || "client.os.name" || Operating system name ||
|| META_BROWSER_OS || "client.browser.name" || Web browser name ||
|| META_CLIENT_KERNEL_VERSION || "client.kernel.version" || Operating system kernel version ||
|| META_CLIENT_VERSION || "client.version" || NDT client version ||

==== META protocol ====

Server MUST start this test by sending TEST_PREPARE empty message followed by TEST_START empty message.

Next, Client SHOULD send meta data encoded as strings in the TEST_MSG messages:
{{{
meta_data_KEY:meta_data_VALUE
}}}

For example:

{{{
client.os.name:Linux
}}}

Client MUST finish uploading its meta data by sending an empty TEST_MSG message.

At the end Server MUST close META test session by sending an empty TEST_FINALIZE message.