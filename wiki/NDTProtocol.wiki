#summary Description of the NDT Protocol

= Network Diagnostic Tool Protocol (NDTP) =

== Abstract == 

The Network Diagnostic Tool (NDT) is a client/server program that provides network configuration and performance testing to a user's computer. It uses a well-defined protocol to provide a reliable communication link between client and server. This protocol documentation is sufficient to allow outside parties to write compatible NDT clients without consulting the NDT source code. This documentation contains a state transition diagrams detailing the various states that the components (both server and client) can be in, and the valid messages that can or will be transmitted or received in those states.

== Table of Contents ==

<wiki:toc max_depth="4" />

== Introduction ==

Several studies have shown that the majority of network performance problems occur in or near the usersâ€™ desktop/laptop computer.  These problems include, but are not limited to, duplex mismatch conditions on Ethernet/FastEthernet links, incorrectly set TCP buffers in the local network infrastructure (e.g. first hop switch/router, hubs, etc.) and bad or dirty cables. NDT seeks to determine why a network connection exhibits certain performance characteristics. In addition to measuring the familiar upload and download speeds of a user's connection, NDT also performs tests that can assess factors such as latency, packet loss, congestion, bad cables, out of order delivery and bottlenecks on the end-to-end path from client to server (on either side of the connection). 

NDT popularity has grown in recent years, which led to an increased interest from the developers community around the world. People started to integrate NDT with their systems using different approaches, like adding Web Developer's API to a Web based (java applet) client and writing a new mobile (Android based) client.

NDTP is allowing outside parties to easily extend both NDT server and client parts and write compatible clients in new languages that will be able to communicate with the publicly available Measurement Lab servers.

In this document, the key words "MUST", "REQUIRED", "SHOULD", "RECOMMENDED", and "MAY" are to be interpreted as described in [http://www.ietf.org/rfc/rfc2119.txt RFC2119].

=== Relationship of Tests and Control Protocols ===

NDTP actually consists of two inter-related sets of protocols: NDTP-Control and NDTP-Tests. NDTP-Control is used to initiate, start, and stop test sessions and to fetch their results, whereas NDTP-Tests is a set of smaller sub-protocols concentrated on testing specific network performance problems.

NDTP-Tests consists of five smaller sub-protocols: Middlebox test, Simple firewall test, C2S throughput test, S2C throughput test and META test. These tests are completely independent from each other and can be run in any order. Moreover, new NDTP-Tests protocols can be easily created and integrated into the existing tests ecosystem.

NDTP-Control is designed to support the negotiation of test sessions and results retrieval in a straightforward manner. At session initiation, there is a negotiation of the test suite and session start time. Moreover, server version is being verified to discover the possibility of incompatibilities. Additionally, NDTP-Control defines an exact message format, which greatly increase the general protocol reliability and allows other NDTP-Tests protocols to communicate in a convenient and more structured fashion.

NDTP-Control protocol can effectively be used to implement not only new types of clients, but also can be treated as a generic framework to create and combine with each other completely new NDTP-Tests protocols.

=== Logical Model ===

Several different roles on both NDTP-Control and NDTP-Tests levels can be distinguished. Specifically, the following ones should be highlighted:

|| *Role* || *Description* ||
|| Session-Sender || The sending endpoint of a NDTP-Tests session. ||
|| Session-Receiver || The receiving endpoint of a NDTP-Tests session. ||
|| Server || An end system that manages NDTP-Control and NDTP-Tests sessions, performs the specific tests needed to determine what problems, if any, exist. The server process then analyzes the test results and returns these results to the client. ||
|| Client || An end system that initiates requests for NDTP-Tests sessions, triggers the start of a set of sessions and receives tests results. ||

Different logical roles can be played by the same host. For example the Server machine is a Session-Sender in the S2C throughput test, while it is a Session-Receiver in the C2S throughput test.

Please look at the figures describing two main NDTP-Tests protocols:

 * C2S throughput test

{{{
       +----------------+                    +------------------+
       |     Client     |<---NDTP-Control--->|     Server       |
       |                |                    |                  |
       | Session-Sender |----NDTP-Test------>| Session-Receiver |
       +----------------+                    +------------------+
}}}

 * S2C throughput test

{{{
       +------------------+                    +------------------+
       |     Client       |<---NDTP-Control--->|     Server       |
       |                  |                    |                  |
       | Session-Receiver |<---NDTP-Test-------|  Session-Sender  |
       +------------------+                    +------------------+
}}}

== Protocol Overview ==

As described above, NDTP consists of two inter-related sets of protocols: NDTP-Control and NDTP-Tests. Both of them are layered over TCP. The former is used to initiate and control test sessions and to fetch their results. The latter set of protocols is used to perform specific tests.

The initiator of the test session establishes a TCP connection to a well-known port, 3001, on the target point and this connection remains open for the duration of the NDTP-Tests sessions.  A NDT server SHOULD listen to this well-known port, but it MAY also choose to listen on a different port, because both client and server are configurable to allow this.

NDTP-Control messages are transmitted before NDTP-Tests sessions are actually started, after they are completed and between particular tests from the performed test suite. Moreover, specific tests also use NDTP-Control messages to synchronise test sessions, exchange configuration data and additional information.

All multi-octet quantities defined in this document are represented as unsigned integers in network byte order unless specified otherwise.

== NDTP-Control ==

The type of each NDTP-Control message can be found after reading the first octet. The length of each NDTP-Control message can be computed upon reading its fixed-size part. No message is shorter than 3 octets.

An implementation SHOULD expunge unused state to prevent denial-of-service attacks, or unbounded memory usage, on the server.  For example, if the full control message is not received within some number of seconds after it is expected, the TCP connection associated with the NDTP-Control session SHOULD be dropped. NDTP does not define any timeout limit.

=== Message structure ===

Each of the NDTP-Control messages always has the following format:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      TYPE     |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     |                                                               |
     .                                                               .
     .                                                               .
     .                                                               .
     |                                                               |
     |                                                               |
     |                                                               |
     |                 Message (up to 65545 octets)                  |
     |                                                               |
     |                                                               |
     |                                                               |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

=== Message types ===

NDTP-Control currently defines the following types of messages:

|| *Symbolic name* || *Bit value* || *Description* ||
|| COMM_FAILURE || 0 || Notification about communication link failure. *Not used explicitly* ||
|| SRV_QUEUE || 1 || Message used to Clients' queue management ||
|| MSG_LOGIN || 2 || Used during initialisation to negotiate NDT version and test suite ||
|| TEST_PREPARE || 3 || Used to send all information needed for a particular test (i.e. port numbers, test time, etc.) ||
|| TEST_START || 4 || Message used to start a specific test ||
|| TEST_MSG || 5 || Used during tests to communicate between Client and Server ||
|| TEST_FINALIZE || 6 || Message used to end a specific test ||
|| MSG_ERROR || 7 || Used to send error messages and notifications about invalid states of the test session ||
|| MSG_RESULTS || 8 || Contains final test sessions' results ||
|| MSG_LOGOUT || 9 || This is the last message send by Server after MSG_RESULTS messages. Server SHOULD close the NDTP-Control connection after sending this message. ||
|| MSG_WAITING || 10 || Message from the Client to notify Server that the Client is still alive ||

=== Sequence diagram ===

A test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |---------------CONNECT---------------->|
               |                                       |
               |----------MSG_LOGIN (TESTS)----------->|
               |                                       |
               |<---------KICK OFF MESSAGE-------------|
               |                                       |
               |<---------SRV_QUEUE ("0")--------------|
               |                                       |
               |<-------MSG_LOGIN ("vVERSION")---------|
               |                                       |
               |<------MSG_LOGIN ("tests' ids")--------|
               |                                       |
               |                                       |
               |<-------------NDTP-Tests-------------->|
               .                                       .
               .                                       .
               .                                       .
               |<-------------NDTP-Tests-------------->|
               |                                       |
               |                                       |
               |<------------MSG_RESULTS---------------|
               .                                       .
               .                                       .
               .                                       .
               |<------------MSG_RESULTS---------------|
               |                                       |
               |                                       |
               |<------------MSG_LOGOUT----------------|
               |                                       |
               |<---------CLOSE CONNECTION------------x|
}}}

=== Connection Setup ===

==== Logging in to server with a test suite request ====

Before Client can start test sessions, it has to establish a connection to the Server.

First, a Client opens a TCP connection to the Server on a well-known port 3001 and sends a LOGIN message:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      2        |              1                |     TESTS     |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

Where TESTS is a bitwise OR of the tests' ids that should be run in a requested test-suite. Tests' ids are defined in the [NDTProtocol#NDTP-Tests NDTP-Tests] section.

All new Clients MUST always request TEST_STATUS (16 (1L << 4)) test in order to notify Server that they support MSG_WAITING messages introduced in NDT v3.5.5.

==== Kick off message to disconnect old clients ====

In the same time Server sends the specially crafted 13 octets long data that kicks off the old Clients ("123456 654321"):

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |     '1'       |     '2'       |     '3'       |     '4'       |
     |     '5'       |     '6'       |     ' '       |     '6'       |
     |     '5'       |     '4'       |     '3'       |     '2'       |
     |     '1'       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     +-+-+-+-+-+-+-+-+
}}}

All non-compatible Clients MUST drop the connection after receiving the above message.

==== Queuing clients ====

The NDT Server MUST respond with one or more SRV_QUEUE messages to inform the Client whether or not it needs to wait, or can start performing tests. These messages MUST contain one of the following string values:

|| *SRV_QUEUE value* || *Description* ||
|| "0" || Test session will start now ||
|| "9977" || Server Fault: test session will be terminated for unknown reason. Client MUST drop the connection after receiving this message. *Not used currently by the Server* ||
|| "9988" || If this is a first message from Server, then it means that Server is busy. In other cases it means Server Fault. Client MUST drop the connection after receiving this message. ||
|| "9999" || Server Busy: Please wait 60 seconds for the current test to finish. Client MUST drop the connection after receiving this message. *Deprecated/Not used by the Server* ||
|| "9990" || This is a check from Server to verify if the Client is alive. Available from v3.5.5. The Client MUST respond to this message by sending an empty 'MSG_WAITING' message. Server will only send these messages when Client requested TEST_STATUS test. ||
|| "N" || Where N is any other value. It means the estimated number of minutes that Client will wait for its test to begin. ||

When the NDT Server decides that the Client can start its test session, it sends SRV_QUEUE message with value *'0'*:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      1        |              1                |     '0'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}


==== Verifying version compatibility ====

At the beginning of the test session the Server and the Client MUST verify their version compatibility.

The Server MUST send a MSG_LOGIN message containing its version identifier in the following form:

{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      2        |          LENGTH               |     'v'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                                                               |
     |                       VERSION number                          |
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

where VERSION is the current NDT version encoded as ascii string, for example *"3.6.4"*.

It is RECOMMENDED, that the Client will display a warning message in case of the difference. Moreover, the Client MAY also drop a connection when incompatibility is too big.

==== Negotiating test suite ====

In the next step the NDT Server MUST send a MSG_LOGIN message containing a list of tests' ids, encoded as ascii string, that will be performed:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      2        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .          List of tests' ids encoded as ascii string           .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}


This list is a string containing space separated numbers that describes particular tests. The test suite containing all five tests (Middlebox test, Simple firewall test, C2S throughput test, S2C throughput test and META test) will have the following description:
{{{
1 8 2 4 32
}}}

The Client MUST drop the connection when it receives unknown test id, because such situation means an error on the Server's part.

The next step is to run the negotiated test suite. The tests MUST be performed in the order received from the Server. Any specific test related configuration (like port numbers, test duration, etc.) MUST be negotiated by the particular NDTP-Tests sub-protocol.

=== Results retrieval ===

After the last accomplished NDTP-Tests test (particular NDTP-Tests sub-protocols are described in the [NDTProtocol#NDTP-Tests NDTP-Tests] section) the Server MUST send all gathered results to the client. These results MUST be sent in a set of MSG_RESULTS messages:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      8        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .               Results encoded as ascii string                 .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

All standard results are currently encoded as strings and MAY be displayed by Client directly on the screen without any modifications.

At the end Server MUST close the whole test session by sending an empty MSG_LOGOUT message and closing connection with the Client.

== NDTP-Tests ==

NDTP-Tests currently defines the following types of tests:

|| *Symbolic name* || *Integer value* || *Description* ||
|| TEST_MID || 1 (1L << 0) || Middlebox test - a short throughput S2C test with a limited CWND to check for a duplex mismatch condition. Moreover, it also checks the MSS value and does NAT detection ||
|| TEST_C2S || 2 (1L << 1) || C2S throughput test ||
|| TEST_S2C || 4 (1L << 2) || S2C throughput test ||
|| TEST_SFW || 8 (1L << 3) || Simple firewall test ||
|| TEST_META || 32 (1L << 5) || META test ||

Moreover, NDT v3.5.5 introduced a new mechanism to avoid zombie Clients (i.e. queued Clients that will never start their test session). In order to enable this mechanism Client MUST add the following test to its test suite request:

|| *Symbolic name* || *Integer value* || *Description* ||
|| TEST_STATUS || 16 (1L << 4) || Special flag to notify Server that this Client will respond to status requests ||

All new Clients MUST support TEST_STATUS mechanism.

=== Middlebox test ===

Middlebox test is a short throughput S2C test with a limited CWND to check for a duplex mismatch condition. Moreover, this test uses pre-defined MSS value to check if any intermediate node will modify its connection settings.

==== MID protocol ====

All messages exchanged between the Client and the Server during the MID protocol are sent using the same connection and message format as NDTP-Control protocol.

As a first step the Server MUST bind a new port and send a TEST_PREPARE message containing this port number to the Client:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      3        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .            Port number encoded as ascii string                .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

The port number must be encoded as string.

Next, the Client MUST connect to this newly bound port and start reading data from the Server.

When the Client successfully connects, the NDT Server MUST start 5 seconds throughput test on the newly created connection.

The NDT Server in the MID Throughput test MUST send packets through the newly opened connection as fast as possible (i.e. without any delays) for 5 seconds. These packets must have the following size:
{{{
2 * (The current maximum segment size (MSS))
}}}

If for some reasons it is not possible to send such packets, the Server MUST send a 8192 Byte packets. The content of these packets SHOULD be as random as possible and MUST include only printable characters.

When the test is over, Server MUST send its results encoded as strings in a TEST_MSG message to Client:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .       ServerIP;ClientIP;CurMSS;WinScaleSent;WinScaleRecv      .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

Next, the Client MUST send to the Server its calculated throughput value encoded as string (float format) in a TEST_MSG message.

At the end the Server MUST close the MID test session by sending an empty TEST_FINALIZE message.

A Middlebox test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |                   |----BIND NEW PORT--|
               |                                       |
               |<---------TEST_PREPARE (PORT)----------|
               |                                       |
               |------------CONNECT (PORT)------------>|
               |                                       |
               |                                       |
               |<----5 seconds s2c Throughput test-----|
               .                                       .
               .                                       .
               .                                       .
               |<----5 seconds s2c Throughput test-----|
               |                                       |
               |                                       |
               |<---------TEST_MSG (RESULTS)-----------|
               |                                       |
               |----------TEST_MSG (CLIENT RESULTS)--->|
               |                                       |
               |<----------TEST_FINALIZE---------------|
               |                                       |
               |<------CLOSE CONNECTION (PORT)--------x|
}}}


=== Simple firewall test ===

Simple firewall test tries to find out any firewalls between Client and Server that will prevent connections to ephemeral port numbers. Test is performed in both directions (i.e. Client is trying to connect to Server (c2s) and Server is trying to connect to Client (s2c)).

==== SFW protocol ====

As a first step the Server MUST bind ephemeral port and send a TEST_PREPARE message containing this port number and test time (in seconds) to the Client:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      3        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .       Port number and test time encoded as ascii string       .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

Port number and test time MUST be encoded as strings and separated by a single space, for example:
{{{
50123 3
}}}

Next, the Client MUST bind ephemeral port and send a TEST_MSG message containing only this port number to the Server. the port number MUST be encoded as string.

The NDT Server MUST start the test by sending an empty TEST_START message immediately after it receives the Client's ephemeral port number.

The test MUST be performed in both direction in parallel. The Client MUST try to connect to the Server's ephemeral port and MUST send a TEST_MSG message containing a pre-defined string "Simple firewall test" of length 20. The whole message looks as following:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            20                 |     'S'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |     'i'       |     'm'       |     'p'       |     'l'       |
     |     'e'       |     ' '       |     'f'       |     'i'       |
     |     'r'       |     'e'       |     'w'       |     'a'       |
     |     'l'       |     'l'       |     ' '       |     't'       |
     |     'e'       |     's'       |     't'       +-+-+-+-+-+-+-+-+
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

After performing the Simple firewall test in both directions, the Server MUST send to the Client its SFW (c2s) results encoded as string in the TEST_MSG message:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            LENGTH             | SFW_RESULT    |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

The Simple firewall test defines the following result codes for both c2s and s2c tests:

|| *Value* || *Description* ||
|| "0" || Test was not started ||
|| "1" || Test was successful (i.e. connection to ephemeral port was possible) ||
|| "2" || There was a connection to ephemeral port, but it was not recognized properly ||
|| "3" || There was no connection to ephemeral port within the specified time ||

At the end the Server MUST close the SFW test session by sending an empty TEST_FINALIZE message.

A Simple firewall test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |                   |----BIND NEW PORT--|
               |                                       |
               |<----TEST_PREPARE (S_PORT TEST_TIME)---|
               |                                       |
               |--BIND NEW PORT----|                   |
               |                                       |
               |----------TEST_MSG (C_PORT)----------->|
               |                                       |
               |<-------------TEST_START---------------|
               |                                       |
               |-----------CONNECT (S_PORT)----------->|
               |<----------CONNECT (C_PORT)------------|
               |---TEST_MSG ("Simple firewall test")-->|
               |<--TEST_MSG ("Simple firewall test")---|
               |                                       |
               |<---------TEST_MSG (RESULTS)-----------|
               |                                       |
               |<----------TEST_FINALIZE---------------|
               |                                       |
               |<-----CLOSE CONNECTION (S_PORT)-------x|
               |x-----CLOSE CONNECTION (C_PORT)------->|
}}}

=== C2S throughput test ===

The C2S throughput test tests the achievable network bandwidth from the client to the server by performing a 10 second memory-to-memory data transfer.

==== C2S protocol ====

As a first step the Server MUST bind new port and send a TEST_PREPARE message containing this port number to the Client:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      3        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .              Port number encoded as ascii string              .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

The port number must be encoded as string.

Next, the Client MUST connect to this newly bound port.

In order to start the test, the Server MUST send an empty TEST_START message.

The Client MUST start 10 seconds throughput test and the Server MUST read transmitted data.

The NDT Client in the C2S Throughput test MUST send a 8192 Byte packets through the newly opened connection as fast as possible (i.e. without any delays) for 10 seconds. The content of these packets SHOULD be as random as possible and MUST include only printable characters.

When the Client stops streaming test data (or the test routine at Server times out), the Server MUST send to the Client its calculated throughput value encoded as string (float format) in the TEST_MSG message:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .   Client's throughput value encoded as string (float fomat)   .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

At the end the Server MUST close the C2S test session by sending an empty TEST_FINALIZE message.

A C2S throughput test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |                   |----BIND NEW PORT--|
               |                                       |
               |<---------TEST_PREPARE (PORT)----------|
               |                                       |
               |------------CONNECT (PORT)------------>|
               |                                       |
               |<-------------TEST_START---------------|
               |                                       |
               |                                       |
               |----10 seconds c2s Throughput test---->|
               .                                       .
               .                                       .
               .                                       .
               |----10 seconds c2s Throughput test---->|
               |                                       |
               |                                       |
               |<---------TEST_MSG (RESULTS)-----------|
               |                                       |
               |<----------TEST_FINALIZE---------------|
               |                                       |
               |<------CLOSE CONNECTION (PORT)--------x|
}}}

=== S2C throughput test ===

The S2C throughput test tests the achievable network bandwidth from the Server to the Client by performing a 10 second memory-to-memory data transfer.

The NDT Server uses a [http://www.web100.org/ web100] project to perform a detailed connection measurements. This means that the Server is also collecting the web100 data variables, that MUST be send to the Client at the end of the whole test session. All available web100 data variables are described in [NDTProtocol#Appendix_A._web100_variables Appendix A].

==== S2C protocol ====

As a first step the Server MUST bind new port and send a TEST_PREPARE message containing this port number to the Client:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      3        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .              Port number encoded as ascii string              .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

The port number must be encoded as string.

Next, the Client MUST connect to this newly bound port.

In order to start the test, the Server MUST send an empty TEST_START message.

The Server MUST start 10 seconds throughput test and the Client MUST read transmitted data.

The NDT Server in the S2C Throughput test MUST send a 8192 Byte packets through the newly opened connection as fast as possible (i.e. without any delays) for 10 seconds. The content of these packets SHOULD be as random as possible and MUST include only printable characters.

When the Server stops streaming test data, it MUST send to the Client its calculated throughput value (encoded as string in float format), amount of unsent data in the socket send queue (encoded as string in integer format) and overall number of sent bytes (encoded as string in float format) in the TEST_MSG message:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .             THROUGHPUT_VALUE SND_QUEUE SENT_BYTES             .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

All these values MUST be separated by spaces.

Next, the Client MUST send to the Server its calculated throughput value encoded as string (float format) in the TEST_MSG message:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .                        THROUGHPUT_VALUE                       .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

In the same time the Server SHOULD send its web100 data variables gathered during S2C throughput test to the Client. Each variable name/value pair should be encoded as strings in a separate TEST_MSG message using the following format:
{{{
web100_var_NAME: web100_var_VALUE\n
}}}

where '\n' is a single new line character.

All available web100 data variables are described in [NDTProtocol#Appendix_A._web100_variables Appendix A].

At the end the Server MUST close the S2C test session by sending an empty TEST_FINALIZE message.

A S2C throughput test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |                   |----BIND NEW PORT--|
               |                                       |
               |<---------TEST_PREPARE (PORT)----------|
               |                                       |
               |------------CONNECT (PORT)------------>|
               |                                       |
               |<-------------TEST_START---------------|
               |                                       |
               |                                       |
               |<---10 seconds s2c Throughput test-----|
               .                                       .
               .                                       .
               .                                       .
               |<---10 seconds s2c Throughput test-----|
               |                                       |
               |                                       |
               |<---------TEST_MSG (RESULTS)-----------|
               |                                       |
               |-------TEST_MSG (CLIENT RESULTS)------>|
               |                                       |
               |                                       |
               |<-------TEST_MSG (WEB100 VARS)---------|
               .                                       .
               .                                       .
               .                                       .
               |<-------TEST_MSG (WEB100 VARS)---------|
               |                                       |
               |                                       |
               |<----------TEST_FINALIZE---------------|
               |                                       |
               |<------CLOSE CONNECTION (PORT)--------x|
}}}


=== META test ===

The META test allows the Client to send an additional information to the Server to be included along with the overall set of test results. Information received from the Client is encoded as key/value pairs.

==== META protocol ====

The Server MUST start this test by sending an empty TEST_PREPARE message followed by an empty TEST_START message.

Next, the Client SHOULD send meta data encoded as strings in the TEST_MSG messages:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            LENGTH             |               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |                                                               |
     .                meta_data_KEY:meta_data_VALUE                  .
     .                                                               .
     .                                                               .
     |                                                               |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

For example:
{{{
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |      5        |            20                 |     'c'       |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               |
     |     'l'       |     'i'       |     'e'       |     'n'       |
     |     't'       |     '.'       |     'o'       |     's'       |
     |     '.'       |     'n'       |     'a'       |     'm'       |
     |     'e'       |     ':'       |     'L'       |     'i'       |
     |     'n'       |     'u'       |     'x'       +-+-+-+-+-+-+-+-+
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
}}}

Both parts (keys and values) of the meta data MUST be strings with the following constraints:
 * Keys MUST be shorter than 64 characters
 * Values MUST be shorter than 256 characters

Although this protocol is generic enough to store any type of information (encoded as strings), it is RECOMMENDED to store at least the following data (the Server MUST properly recognize these keys):

|| *Key name* || *Description* ||
|| "client.os.name" || Operating system name in a short format (for example "Linux", "Windows NT", "Mac OS", etc.) ||
|| "client.browser.name" || Web browser name with a version number (for example "MSIE 7.0", "Firefox/3.6.18", etc.) ||
|| "client.kernel.version" || Operating system kernel version (for example "2.6.35-30-server") ||
|| "client.version" || NDT client version (for example "3.6.4") ||

The Client MUST finish uploading its meta data by sending an empty TEST_MSG message.

At the end the Server MUST close the META test session by sending an empty TEST_FINALIZE message.

A META test session overview can be seen on the following sequence diagram:

{{{
       +----------------+                    +------------------+
       |     Client     |                    |     Server       |
       +----------------+                    +------------------+
               |                                       |
               |<------------TEST_PREPARE--------------|
               |                                       |
               |<-------------TEST_START---------------|
               |                                       |
               |                                       |
               |----------TEST_MSG (META DATA)-------->|
               .                                       .
               .                                       .
               .                                       .
               |----------TEST_MSG (META DATA)-------->|
               |                                       |
               |                                       |
               |--------------TEST_MSG---------------->|
               |                                       |
               |<----------TEST_FINALIZE---------------|

}}}

= Appendix A. web100 variables =

|| CurMSS || The current maximum segment size (MSS), in octets.||
|| X_Rcvbuf || The socket receive buffer size in octets.  Note that the meaning of this variable is implementation dependent.  In particular, it may or may not include the reassembly queue. ||
|| X_Sndbuf || The socket send buffer size in octets.  Note that the meaning of this variable is implementation dependent. Particularly, it may or may not include the retransmit queue. ||
|| !AckPktsIn || The number of valid pure ack packets that have been received on this connection by the Local Host. ||
|| !AckPktsOut || The number of pure ack packets that have been sent on this connection by the Local Host. ||
|| !BytesRetrans || The number of octets retransmitted. ||
|| !CongAvoid || The number of times the congestion window has been increased by the Congestion Avoidance algorithm. ||
|| !CongestionOverCount || The number of congestion events which were 'backed out' of the congestion control state machine such that the congestion window was restored to a prior value. This can happen due to the Eifel algorithm [http://www.ietf.org/rfc/rfc3522.txt RFC3522] or other algorithms which can be used to detect and cancel spurious invocations of the Fast Retransmit Algorithm. ||
|| !CongestionSignals || The number of multiplicative downward congestion window adjustments due to all forms of congestion signals, including Fast Retransmit, ECN and timeouts. This object summarizes all events that invoke the MD portion of AIMD congestion control, and as such is the best indicator of how cwnd is being affected by congestion. ||
|| CountRTT || The number of round trip time samples included in tcpEStatsPathSumRTT and tcpEStatsPathHCSumRTT. ||
|| !CurCwnd || The current congestion window, in octets. ||
|| CurRTO || The current value of the retransmit timer RTO. ||
|| !CurRwinRcvd || The most recent window advertisement received, in octets. ||
|| !CurRwinSent || The most recent window advertisement sent, in octets. ||
|| !CurSsthresh || The current slow start threshold in octets. ||
|| DSACKDups || The number of duplicate segments reported to the local host by D-SACK blocks. ||
|| !DataBytesIn || The number of octets contained in received data segments, including retransmitted data.  Note that this does not include TCP headers. ||
|| !DataBytesOut || The number of octets of data contained in transmitted segments, including retransmitted data.  Note that this does not include TCP headers. ||
|| !DataPktsIn || The number of segments received containing a positive length data segment. ||
|| !DataPktsOut || The number of segments sent containing a positive length data segment. ||
|| !DupAcksIn || The number of duplicate ACKs received. ||
|| ECNEnabled || Enabled(1) if Explicit Congestion Notification (ECN) has been negotiated on, selfDisabled(2) if it is disabled or not implemented on the local host, or peerDisabled(3) if not negotiated by the remote hosts. ||
|| !FastRetran || The number of invocations of the Fast Retransmit algorithm. ||
|| !MaxCwnd || The maximum congestion window used during Slow Start, in octets. ||
|| MaxMSS || The maximum MSS, in octets. ||
|| MaxRTO || The maximum value of the retransmit timer RTO. ||
|| MaxRTT || The maximum sampled round trip time. ||
|| !MaxRwinRcvd || The maximum window advertisement received, in octets. ||
|| !MaxRwinSent || The maximum window advertisement sent, in octets. ||
|| !MaxSsthresh || The maximum slow start threshold, excluding the initial value. ||
|| MinMSS || The minimum MSS, in octets. ||
|| MinRTO || The minimum value of the retransmit timer RTO. ||
|| MinRTT || The minimum sampled round trip time. ||
|| !MinRwinRcvd || The minimum window advertisement received, in octets. ||
|| !MinRwinSent || The minimum window advertisement sent, excluding the initial unscaled window advertised on the SYN, in octets. ||
|| !NagleEnabled || True(1) if the Nagle algorithm is being used, else false(2). ||
|| !OtherReductions || The number of congestion window reductions made as a result of anything other than AIMD congestion control algorithms. Examples of non-multiplicative window reductions include Congestion Window Validation [http://www.ietf.org/rfc/rfc2861.txt RFC2861] and experimental algorithms such as Vegas. ||
|| !PktsIn || The total number of segments received. ||
|| !PktsOut || The total number of segments sent. ||
|| !PktsRetrans || The number of segments transmitted containing at least some retransmitted data. ||
|| !RcvWinScale || The value of Rcv.Wind.Scale.  Note that !RcvWinScale is either zero or the same as !WinScaleSent. ||
|| SACKEnabled || True(1) if SACK has been negotiated on, else false(2). ||
|| SACKsRcvd || The number of SACK options received. ||
|| !SendStall || The number of interface stalls or other sender local resource limitations that are treated as congestion signals. ||
|| !SlowStart || The number of times the congestion window has been increased by the Slow Start algorithm. ||
|| SampleRTT || The most recent raw round trip time measurement used in calculation of the RTO. ||
|| SmoothedRTT || The smoothed round trip time used in calculation of the RTO. See SRTT in [http://www.ietf.org/rfc/rfc2988.txt RFC2988]. ||
|| !SndWinScale || The value of Snd.Wind.Scale.  Note that !SndWinScale is either zero or the same as !WinScaleRcvd. ||
|| !SndLimTimeRwin || The cumulative time spent in the 'Receiver Limited' state. ||
|| !SndLimTimeCwnd || The cumulative time spent in the 'Congestion Limited' state. ||
|| !SndLimTimeSender || The cumulative time spent in the 'Sender Limited' state. ||
|| !SndLimTransRwin || The number of transitions into the 'Receiver Limited' state from either the 'Congestion Limited' or 'Sender Limited' states. This state is entered whenever TCP transmission stops because the sender has filled the announced receiver window. ||
|| !SndLimTransCwnd || The number of transitions into the 'Congestion Limited' state from either the 'Receiver Limited' or 'Sender Limited' states. This state is entered whenever TCP transmission stops because the sender has reached some limit defined by congestion control (e.g. cwnd) or other algorithms (retransmission timeouts) designed to control network traffic. ||
|| !SndLimTransSender || The number of transitions into the 'Sender Limited' state from either the 'Receiver Limited' or 'Congestion Limited' states. This state is entered whenever TCP transmission stops due to some sender limit such as running out of application data or other resources and the Karn algorithm. When TCP stops sending data for any reason which can not be classified as Receiver Limited or Congestion Limited it MUST be treated as Sender Limited. ||
|| !SndLimBytesRwin || The cumulative bytes sent while in the 'Receiver Limited' state, as determined by the Local Host, when the Local Host is a sender.  This state is entered whenever TCP transmission stops due to Receiver not being able to receive data. ||
|| !SndLimBytesCwnd ||The cumulative bytes sent while in the 'Congestion Limited' state, as determined by the Local Host, when the Local Host is a sender.  This state is entered whenever TCP transmission stops due to congestion. ||
|| !SndLimBytesSender || The cumulative bytes sent while in the 'Sender Limited' state, as determined by the Local Host, when the Local Host is a sender.  This state is entered whenever TCP transmission stops because there is no more data in sender's buffer. ||
|| !SubsequentTimeouts || The number of times the retransmit timeout has expired after the RTO has been doubled. See section 5.5 in [http://www.ietf.org/rfc/rfc2988.txt RFC2988]. ||
|| SumRTT || The sum of all sampled round trip times. ||
|| Timeouts || The number of times the retransmit timeout has expired when the RTO backoff multiplier is equal to one. ||
|| !TimestampsEnabled || Enabled(1) if TCP timestamps have been negotiated on, selfDisabled(2) if they are disabled or not implemented on the local host, or peerDisabled(3) if not negotiated by the remote hosts. ||
|| !WinScaleRcvd || The value of the received window scale option if one was received; otherwise, a value of -1. ||
|| !WinScaleSent || The value of the transmitted window scale option if one was sent; otherwise, a value of -1. ||
|| !DupAcksOut || The number of duplicate ACKs sent. ||
|| !StartTimeUsec || The value of sysUpTime at the time this listener was established.  If the current state was entered prior to the last re-initialization of the local network management subsystem, then this object contains a zero value. ||
|| Duration || The seconds part of the time elapsed between !StartTimeStamp and the most recent protocol event (segment sent or received). ||