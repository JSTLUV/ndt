#summary Description of the data collected by NDT

=Data collected by the NDT= 

== Abstract == 

The Network Diagnostic Tool (NDT) is a client/server program that provides network configuration and performance testing to a user's computer. The measured factors along with some additional analysis and detailed test traces are stored by the server for the future reuse. Moreover, multi-level results allow novice and expert users to view and understand the test results.

== Table of Contents ==

<wiki:toc max_depth="3" />

== Introduction ==

The NDT uses the following files to store the test results data:

|| *File* || *Scope of the collected data* || *Always used?* ||
|| *tcpdump trace* || C2S/S2C tests || *NO* (enabled by `-t, --tcpdump` options) ||
|| *web100 snaplog trace* || C2S/S2C tests || *NO* (enabled by `--snaplog` option) ||
|| *web100srv.log* || test session || YES ||
|| *cputime trace* || test session || *NO* (enabled by `--cputime` option) ||
|| *meta data file* || test session || YES ||

==Collected data formats==

===tcpdump trace===

Writing tcpdump trace file is enabled by `-t, --tcpdump` options.

This is a standard trace file for all packets (except the initial syn & syn/ack exchange) written using [http://www.tcpdump.org/ pcap] library.

===web100 snaplog trace===

Writing snaplog file is enabled by `--snaplog` option.

This file contains all the the [http://www.web100.org/ web100] kernel MIB variables' values written in a fixed time (default is 5 msec) increments. The list of logged variables with a short description can be found in the [NDTProtocol#Appendix_A._web100_variables NDT Protocol document].

===web100srv.log file===

The NDT always writes a one-line summary of the test to the web100srv.log file. This one-line summary contains the final values of some of the web100 variables with an additional analysis details.

The particular values are separated with commas without any spaces. The results are stored with the following order:

|| *#* || *Name* || *Description/Comment* ||
|| 1. || date || start time of the test session (in the form "Wed Jun 30 21:49:08 1993\n") ||
|| 2. || client name || remote (client) host fully qualified name ||
|| 3. || MID throughput speed || CWND limited throughput speed measured during Middlebox test (value in kb/s) ||
|| 4. || S2C throughput speed || value in kb/s ||
|| 5. || C2S throughput speed || value in kb/s ||
|| 6. || Timeouts || (*{{{*}}}*) The number of times the retransmit timeout has expired when the RTO backoff multiplier is equal to one. ||
|| 7. || SumRTT || (*{{{*}}}*) The sum of all sampled round trip times. ||
|| 8. || CountRTT || (*{{{*}}}*) The number of round trip time samples included in tcpEStatsPathSumRTT and tcpEStatsPathHCSumRTT. ||
|| 9. || !PktsRetrans || (*{{{*}}}*) The number of segments transmitted containing at least some retransmitted data. ||
|| 10. || !FastRetran || (*{{{*}}}*) The number of invocations of the Fast Retransmit algorithm. ||
|| 11. || !DataPktsOut || (*{{{*}}}*) The number of segments sent containing a positive length data segment. ||
|| 12. || !AckPktsOut || (*{{{*}}}*) The number of pure ack packets that have been sent on this connection by the Local Host. ||
|| 13. || CurMSS || (*{{{*}}}*) The current maximum segment size (MSS), in octets.||
|| 14. || !DupAcksIn || (*{{{*}}}*) The number of duplicate ACKs received. ||
|| 15. || !AckPktsIn || (*{{{*}}}*) The number of valid pure ack packets that have been received on this connection by the Local Host. ||
|| 16. || !MaxRwinRcvd || (*{{{*}}}*) The maximum window advertisement received, in octets. ||
|| 17. || Sndbuf || (*{{{*}}}*) The socket send buffer size in octets. Note that the meaning of this variable is implementation dependent. Particularly, it may or may not include the retransmit queue. ||
|| 18. || !MaxCwnd || (*{{{*}}}*) The maximum congestion window used during Slow Start, in octets. ||
|| 19. || !SndLimTimeRwin || (*{{{*}}}*) The cumulative time spent in the 'Receiver Limited' state. ||
|| 20. || !SndLimTimeCwnd || (*{{{*}}}*) The cumulative time spent in the 'Congestion Limited' state. ||
|| 21. || !SndLimTimeSender || (*{{{*}}}*) The cumulative time spent in the 'Sender Limited' state. ||
|| 22. || !DataBytesOut || (*{{{*}}}*) The number of octets of data contained in transmitted segments, including retransmitted data. Note that this does not include TCP headers. ||
|| 23. || !SndLimTransRwin || (*{{{*}}}*) The number of transitions into the 'Receiver Limited' state from either the 'Congestion Limited' or 'Sender Limited' states. This state is entered whenever TCP transmission stops because the sender has filled the announced receiver window. ||
|| 24. || !SndLimTransCwnd || (*{{{*}}}*) The number of transitions into the 'Congestion Limited' state from either the 'Receiver Limited' or 'Sender Limited' states. This state is entered whenever TCP transmission stops because the sender has reached some limit defined by congestion control (e.g. cwnd) or other algorithms (retransmission timeouts) designed to control network traffic. ||
|| 25. || !SndLimTransSender || (*{{{*}}}*) The number of transitions into the 'Sender Limited' state from either the 'Receiver Limited' or 'Congestion Limited' states. This state is entered whenever TCP transmission stops due to some sender limit such as running out of application data or other resources and the Karn algorithm. When TCP stops sending data for any reason which can not be classified as Receiver Limited or Congestion Limited it MUST be treated as Sender Limited. ||
|| 26. || !MaxSsthresh || (*{{{*}}}*) The maximum slow start threshold, excluding the initial value. ||
|| 27. || CurRTO || (*{{{*}}}*) The current value of the retransmit timer RTO. ||
|| 28. || !CurRwinRcvd || (*{{{*}}}*) The most recent window advertisement received, in octets. ||
|| 29. || link || ||
|| 30. || mismatch || ||
|| 31. || bad_cable || ||
|| 32. || half_duplex || ||
|| 33. || congestion || ||
|| 34. || c2sdata || ||
|| 35. || c2sack || ||
|| 36. || s2cdata || ||
|| 37. || s2cack || ||
|| 38. || !CongestionSignals || (*{{{*}}}*) The number of multiplicative downward congestion window adjustments due to all forms of congestion signals, including Fast Retransmit, ECN and timeouts. This object summarizes all events that invoke the MD portion of AIMD congestion control, and as such is the best indicator of how cwnd is being affected by congestion. ||
|| 39. || !PktsOut || (*{{{*}}}*) The total number of segments sent. ||
|| 40. || MinRTT || (*{{{*}}}*) The minimum sampled round trip time. ||
|| 41. || !RcvWinScale || (*{{{*}}}*) The value of Rcv.Wind.Scale. Note that !RcvWinScale is either zero or the same as !WinScaleSent. ||
|| 42. || autotune || (*deprecated/not used*) This value kept the information about web100 autotune functionality. It could have the following values: 0 - autotune is disabled, 1 - sbufmode autotune is enabled, 2 - rbufmode autotune is enabled, 3 - all autotune modes are enabled, 22 - autotune params cannot be found, 23 - autotune params cannot be read ||
|| 43. || !CongAvoid || (*{{{*}}}*) The number of times the congestion window has been increased by the Congestion Avoidance algorithm. ||
|| 44. || !CongestionOverCount || (*{{{*}}}*) The number of congestion events which were 'backed out' of the congestion control state machine such that the congestion window was restored to a prior value. This can happen due to the Eifel algorithm [http://www.ietf.org/rfc/rfc3522.txt RFC3522] or other algorithms which can be used to detect and cancel spurious invocations of the Fast Retransmit Algorithm. ||
|| 45. || MaxRTT || (*{{{*}}}*) The maximum sampled round trip time. ||
|| 46. || !OtherReductions || (*{{{*}}}*) The number of congestion window reductions made as a result of anything other than AIMD congestion control algorithms. Examples of non-multiplicative window reductions include Congestion Window Validation [http://www.ietf.org/rfc/rfc2861.txt RFC2861] and experimental algorithms such as Vegas. ||
|| 47. || !CurTimeoutCount || (*{{{*}}}*) The current number of times the retransmit timeout has expired without receiving an acknowledgment for new data. tcpEStatsStackCurTimeoutCount is reset to zero when new data is acknowledged and incremented for each invocation of section 5.5 in [http://www.ietf.org/rfc/rfc2988.txt RFC2988]. ||
|| 48. || !AbruptTimeouts || (*{{{*}}}*) The number of timeouts that occurred without any immediately preceding duplicate acknowledgments or other indications of congestion. Abrupt Timeouts indicate that the path lost an entire window of data or acknowledgments. Timeouts that are preceded by duplicate acknowledgments or other congestion signals (e.g., ECN) are not counted as abrupt, and might have been avoided by a more sophisticated Fast Retransmit algorithm. ||
|| 49. || !SendStall || (*{{{*}}}*) The number of interface stalls or other sender local resource limitations that are treated as congestion signals. ||
|| 50. || !SlowStart || (*{{{*}}}*) The number of times the congestion window has been increased by the Slow Start algorithm. ||
|| 51. || !SubsequentTimeouts || (*{{{*}}}*) The number of times the retransmit timeout has expired after the RTO has been doubled. See section 5.5 in [http://www.ietf.org/rfc/rfc2988.txt RFC2988]. ||
|| 52. || !ThruBytesAcked || (*{{{*}}}*) The number of octets for which cumulative acknowledgments have been received, on systems that can receive more than 10 million bits per second.  Note that this will be the sum of changes in tcpEStatsAppSndUna. ||
|| 53. || peaks.min || The minimal value of the CWND peak ||
|| 54. || peaks.max || The maximal value of the CWND peak ||
|| 55. || peaks.amount || The amount of the CWND peaks ||

(*{{{*}}}*) web100 variable

===cputime trace===

This file contains lines with `times` routine results recorded using a 100ms interval.

===meta data file===

This meta data file contains the names of the other files, the clients & servers IP addr and FQDN, and the encoded line of the web100/analysis data. A sample of that data is
 
{{{
[iupui_ndt@mlab1 ~]$ cat /usr/local/ndt/serverdata/
2009/10/09/20091009T20:46:28.
141927000Z_149.20.53.166:63251.meta
Date/Time: 20091009T20:46:28.141927000Z
c2s_snaplog file: 20091009T20:46:28.141927000Z_149.20.53.166:60102.c2s_snaplog.gz
c2s_ndttrace file: 20091009T20:46:28.141927000Z_149.20.53.166:60102.c2s_ndttrace.gz
s2c_snaplog file:
s2c_ndttrace file: 20091009T20:46:28.141927000Z_149.20.53.166:61730.s2c_ndttrace.gz
cputime file:
server IP address: 4.71.254.147
server hostname: mlab1.atl01.measurement-lab.org
server kernel version: 2.6.22.19-vs2.3.0.34.32.mlab.pla
client IP address: 149.20.53.166
client hostname: nb.tech.org
client OS name:
client_browser name:
Summary data:313,2246,1658,0,69963,1020,19,8,1961,0,1448,392,1428,525600,112560,
43440,0,10001122,25307,2899352,0,15,15,21720,270,525600,100,0,0,0,1,6,2,8,10,8,1961,
66,10,22,964,0,166,0,-1208754176,3,0,31,0,360,1448,43440,8
}}}

==Displaying collected data==

The tcpdump files can be read using [http://www.tcpdump.org/ tcpdump] and [http://www.tcptrace.org/ tcptrace] programs.

The NDT package comes with a utility (called genplot) that can convert snaplog trace files into text or xplot graph files. Alternatively the user can write their own analysis program using the web100 library functions.

The NDT server also contains a Java application that can look through the NDT log files and link log entries to trace files, and it also simplifies the viewing of this data. The utility will need to be rewritten slightly to take advantage of the meta files instead of (in addition to) the log files.
 
The detailed tcpdump and snaplog files can be used to re-examine the test to see what happened, i.e.:
  * was there packet loss during the s2c test, and if so when/how often did it occur? 
  * what was the maximum throughput during TCP's slow-start growth phase? 
  * how many times did TCP oscillate in the Congestion Avoidance phase? 
  * did the test compete with other traffic? 
  * was there non-congestive loss on the path? 
  * was the test limited by the user's PC (default tunable settings)? 
  * how often did TCP retransmit packets, and were any of these unnecessary? 
  * were packets being reordered (e.g., sent 1, 2, 3, 4, 5 but received 1, 2, 4, 3, 5) 
  * what was the capacity of the bottleneck link in this path? 
  * did the test produce the expected results? 
  * was the client connected to a wired or wireless (WiFi) network? 
  * is there a firewall and/or NAT box in the path?
 
More information about NDT:
http://www.internet2.edu/performance/ndt/